<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Shared Text</title>
    <style>
        #out {
            display: grid;
            grid-template-columns: repeat( auto-fill, 30ch);
        }
        label {
            font-family:    system-ui;
            font-size:      70%;
            color:          #000a;
            margin-top:     1em;
        }
    </style>
</head>
<body>
<h1>Shared Text</h1>
<button id="add">Add</button>
<button id="add100">Add100</button>
<div id="out"></div>

<script type="module">
    import {
        channelName,
        observableNamesKey,
        obsNameParam,
        readActionName, readActionParam,
        updateActionName,
        updateActionParam
    } from "./sharedConstants.js";
    import {dom, select}                                                                    from "../../kolibri/util/dom.js";
    import "../../kolibri/util/array.js";
    import {Observable}                                                     from "../../kolibri/observable.js";
    import { defaultConsoleLogging }                                        from "../../kolibri/logger/loggingSupport.js";
    import {clientId}                                                       from "../../kolibri/version.js";
    import {client} from "../../kolibri/rest/restClient.js";
    import {Scheduler} from "../../kolibri/dataflow/dataflow.js";
    defaultConsoleLogging("ch.fhnw",LOG_INFO);

    const serverBase = window.location.origin;

    const eventSource = new EventSource(serverBase + '/' + channelName);
    eventSource.addEventListener('message', event =>
        console.warn("unknown event type", event)
    );
    eventSource.addEventListener('error', err =>
        console.warn("SSE error", err)
    );
    eventSource.addEventListener(channelName, event => {
        console.error("not supported", JSON.parse(event.data)[updateActionParam]);
    });

    /**
     * @typedef RemoteObservableType
     * @param { "remote" | "local" } source - remote values are not published (again)
     * @param { String } value              - non-String values have to be stringified
     */

    /** @type { Object.<String, IObservable<RemoteObservableType>> } */
    const boundObs = {}; // model world of obsNames and their respective observables

    const bindRemoteObservable = (model, obsName) => {
        boundObs[obsName] = model;
        eventSource.addEventListener(channelName + "/" + obsName, event => {
            model.setValue( {source:"remote", value: JSON.parse(event.data)[updateActionParam]} );
        });
        const notifyRemote = val => {
            if (val.source === "remote") return; // guard against hysterese
            const text = val.value;
            const data = {
                [obsNameParam]      : obsName,
                [updateActionParam] : text
            };
            client(serverBase + '/' + updateActionName, "POST", data);
        };
        model.onChange( val => notifyRemote(val));
    };

    const projectRemotelyObservableTextInput = (model, obsName) => {
        const [labelElem] = dom(`
            <label id="${obsName}">
                ${obsName}
                <input>
            </label>`);
        const [textInput] = select(labelElem, "input");
        bindRemoteObservable(model, obsName);                                                   // remote binding
        textInput.oninput = _ => model.setValue({source:"local", value: textInput.value});      // view binding
        model.onChange( val => textInput.value = val.value);                                    // data binding
        document.getElementById("out").append(labelElem);
    };


    const projectAllUnknownObsNames = obsNames => {
        // if there is a new one that we haven't projected, yet, we have to do so.
        obsNames
            .filter(obsName => boundObs[obsName] === undefined)
            .forEach(obsName => {
                console.log("project", obsName);
                projectRemotelyObservableTextInput(Observable({source: "remote", value: ""}), obsName);
            });
        // todo: if we have more than what is in obsNames, we might want to delete..
    };

    // just in case there are issues with the initial read, which might be the case when the
    // connection gets stale or the server is otherwise outdated or we have to catch up after
    // a temporary silent time
    fetch(serverBase + '/' + readActionName + '?' + obsNameParam + "=" + observableNamesKey)
        .then( res => res.json())
        .then( data => {
            console.log("initial read", data);
            const obsNames = JSON.parse(data[readActionParam]);
            projectAllUnknownObsNames(obsNames);
        }
    );


    // when there already is one, we should not override the value
    const namesRemoteObservable = Observable({source:"remote", value:JSON.stringify([])});
    bindRemoteObservable(namesRemoteObservable, observableNamesKey);

    namesRemoteObservable.onChange( data => {
       // if we created the new obsName ourselves, then we first get notified locally
       // in any case, we get notified (possibly a second time) from remote
       console.log(data);
       const obsNames = JSON.parse(data.value);
        projectAllUnknownObsNames(obsNames);
    });

    // bind button -> simply add a new obsName and the rest falls in place
    const [addButton] = select(document.body,"#add");
    let runningId = 0;
    addButton.onclick = _ => {
        const names = JSON.parse(namesRemoteObservable.getValue().value);
        names.push("name-" + clientId + "-" + runningId);
        runningId++;
        namesRemoteObservable.setValue( {source:"local", value: JSON.stringify(names)} );
    };

    const [add100Button] = select(document.body,"#add100");
    const scheduler = Scheduler();
    add100Button.onclick = _evt => {
        100..times( n =>  scheduler.addOk (addButton.click()) );
    }


</script>


</body>
</html>
