<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Shared Text</title>
    <style>
        #out {
            display: grid;
            grid-template-columns: repeat( auto-fill, 30ch);
        }
        label {
            font-family:    system-ui;
            font-size:      70%;
            color:          #000a;
            margin-top:     1em;
        }
    </style>
</head>
<body>
<h1>Shared Text</h1>
<button id="add">Add</button>
<div id="out"></div>

<script type="module">
    import {
        channelName,
        observableNamesKey,
        obsNameParam,
        readActionName,
        updateActionName,
        updateActionParam
    } from "./sharedConstants.js";
    import {dom, select}                                                                    from "../../kolibri/util/dom.js";
    import "../../kolibri/util/array.js";
    import {Observable}                                                     from "../../kolibri/observable.js";
    import { defaultConsoleLogging }                                        from "../../kolibri/logger/loggingSupport.js";
    import {clientId}                                                       from "../../kolibri/version.js";
    defaultConsoleLogging("ch.fhnw",LOG_INFO);

    const serverBase = window.location.origin;

    const eventSource = new EventSource(serverBase + '/' + channelName);
    eventSource.addEventListener('message', event =>
        console.warn("unknown event type", event)
    );
    eventSource.addEventListener('error', err =>
        console.warn("SSE error", err)
    );
    eventSource.addEventListener(channelName, event => {
        console.error("not supported", JSON.parse(event.data)[updateActionParam]);
    });

    const boundObs = {}; // model world

    const bindRemoteObservable = (model, obsName) => {
        boundObs[obsName] = model;
        eventSource.addEventListener(channelName + "/" + obsName, event => {
            model.setValue( {source:"remote", value: JSON.parse(event.data)[updateActionParam]} );
        });
        const notifyRemote = val => {
            if (val.source === "remote") return; // guard against hysterese
            const text = val.value;
            if (text.length > 8000) {
                console.error("update: max text length is 8000 but was " + text.length);
                return;
            }
            fetch(serverBase + '/' + updateActionName + '?' + updateActionParam + '=' + text + "&" + obsNameParam + "=" + obsName); // url encoding is automatic
        };
        model.onChange( val => notifyRemote(val));
    };

    const projectRemotelyObservableTextInput = (model, obsName) => {
        const [labelElem] = dom(`
            <label id="${obsName}">
                ${obsName}
                <input>
            </label>`);
        const [textInput] = select(labelElem, "input");
        bindRemoteObservable(model, obsName);                                                   // remote binding
        textInput.oninput = _ => model.setValue({source:"local", value: textInput.value});      // view binding
        model.onChange( val => textInput.value = val.value);                                    // data binding
        document.getElementById("out").append(labelElem);
    };


    // just in case there are issues with the initial read, which might be the case when the
    // connection gets stale or the server is otherwise outdated or we have to catch up after
    // a temporary silent time
    // fetch(serverBase + '/' + readActionName + '?' + obsNameParam + "=" + observableNamesKey)
    //     .then( res => res.json())
    //     .then( data => console.log("initial read", data)
    // );


    // when there already is one, we should not override the value
    const namesRemoteObservable = Observable({source:"remote", value:JSON.stringify([])});
    bindRemoteObservable(namesRemoteObservable, observableNamesKey);

    namesRemoteObservable.onChange( val => {
       // if we created the new obsName ourselves, then we first get notified locally
       // in any case, we get notified (possibly a second time) from remote
       console.log(val);
       const obsNames = JSON.parse(val.value);
       // if there is a new one that we haven't projected, yet, we have to do so.
       obsNames
           .filter ( obsName => boundObs[obsName] === undefined)
           .forEach( obsName => {
               console.log("project", obsName);
               projectRemotelyObservableTextInput( Observable({source:"remote", value:""}), obsName);
           });
       // todo: if we have more than what is in obsNames, we might want to delete..
    });

    // bind button -> simply add a new obsName and the rest falls in place
    const [addButton] = select(document.body,"#add");
    let runningId = 0;
    addButton.onclick = _ => {
        const names = JSON.parse(namesRemoteObservable.getValue().value);
        names.push("name-" + clientId + "-" + runningId);
        runningId++;
        namesRemoteObservable.setValue( {source:"local", value: JSON.stringify(names)} );
    };



</script>


</body>
</html>
